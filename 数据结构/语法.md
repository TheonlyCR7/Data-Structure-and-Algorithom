

>   慕课网
>
>   尽量每一行只实现一个功能

## 逻辑结构与物理结构

### 逻辑结构

>   数据对象中数据元素之间的相互关系

集合，线性，树型，图形
![picture](../photo/5.jpg)
![picture](../photo/11.jpg)

### 物理结构

>   数据的逻辑结构在计算机中的存储形式

#### 顺序存储

类似排队占位，数组

#### 链式存储结构

>   把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以不连续

## 抽象数据结构

![picture](../photo/10.jpg)

-   数据结构，反应数据之间的关系
-   数据，类似一个物种
-   数据元素，类似一个物种里的个体，一个类别的不同动物
-   数据对象，是有相同数量和类型的数据项
-   数据项，数据元素的属性，类似人的眼睛，耳朵，姓名，年龄



# @三种依托于静态数组的数据结构

## 数组

```java
int[] arr = new int[20];
创建数组， new分配空间
```

### 数组索引

>   索引可以有意义，映射对应的学号，床位号，单元号
>
>   也可以无意义
>
>   最好应用于索引有语义的情况

数组最大的优点：可以根据索引**快速查询**

为了实现**增，删，改，查**

**基于Java的数组，二次封装我们的数组**

### 使用泛型

-   让我们的数据结构可以放置“任何”数据类型
-   不是基本数据类型，只能是类对象
-   **boolean,byte,char,short,int,long,float,double**
-   每个基本数据类型都有对象的包装类
-   **Boolean，Byte，Char，Short，Int，Long，Float，Double**

### 动态数组

**容量可变化**

### 时间复杂度分析

-   大O描述的是算法的运行时间和输入数据之间的关系

-   忽略常数

-   描述的是渐进时间复杂度，描述n趋近于无穷的情况

-   关注的是最糟情况

    

    关于动态数组的分析（**均摊复杂度**）

    ```java
       //为数组添加数
    public void add(int index, E e) {
    
            if (index < 0 || index >= size) {
                throw new IllegalArgumentException("Add failed. array is full");
            }
    
            //若不够，就扩容
            if(size == data.length)
                resize(2 *data.length);
    
            for (int i = size - 1; i >= index; i--) {
                data[i + 1] = data[i];
            }
            data[index] = e;
            size++;
        }
    ```

    ```java
    //若数组空间不足，则扩容
    private void resize(int newCapacity){
        E[] newData = (E[])new Object[newCapacity];
        for(int i = 0; i < size; i ++)
            newData[i] = data[i];
        data = newData;
    }
    ```

![picture](../photo/1.png)



#### 复杂度震荡

当数组在10个基础上，加一个数据，执行扩容，而去掉一个，又减容，导致



## 栈  Stack

-   一种后进先出的数据结构，类似于串糖葫芦（Last in First Out）
-   进栈，出栈
-   栈是数组的子集
-   只能从一段添加元素，也只能从一端取出元素
-   这一端称为栈顶

### 栈的应用

-   撤销操作
-   程序调用的系统栈（递归）

### 栈的实现



### 栈的具体应用

-   undo操作—



## 队列Queue

-   First  In First Out
-   队列是一种数据结构
-   是数组的子集
-   只能从一端（队尾）添加元素，从另一端（队首）取出元素

### 数组队列

![picture](../photo/2.png)



### 循环队列

-   front指向队列第一次元素

-   tail指向队列最后一个元素的后一位

-   front == tail  队列为空

![picture](../photo/3.png)

-   当发生出队操作时，a出队，只需改变front的指向即可，改为指向1，时间复杂度为O(1)
-   当元素入队到7时，tail则循环到0的位置，position.tail =  (position.tail + 1)%7

![picture](../photo/4.png)

-   当元素再入队时，front = tail  ，但队列不满
-   当（tail + 1）% 7 = front，队列为满

![picture](../photo/12.jpg)



## @真正的动态数据结构

## @线性结构

## 链表Linked List

数据存储在节点中

真正的动态，不需要处理固定容量的问题

不占用过多的内存

缺失了随机访问的能力，不支持索引

![picture](../photo/8.jpg)

![picture](../photo/7.jpg)

### 在链表透添加元素

-   设置虚拟头节点（dummyHead）

### 时间复杂度

增，删，改，查： O(n)

图

### 用链表实现栈

### 用链表实现队列



## 链表与递归

### 递归

>   将原来的问题，转化为更小的同一问题

```java
数组求和
public class Sum{
	
    public static int sum(int[] arr){
        return sum(arr, 0);
    }
    
    private static int sum(int[] arr, int l){
        if(l == arr.length)
            return 0;
        return arr[l] + sum(arr, l + 1);
    }
}
```

![picure](../photo/15.jpg)

![picure](../photo/14.jpg)



```java
public class Solution3 {

    public ListNode removeElements(ListNode head, int val) {

        //最基本的问题
        if(head == null)
            return null;

        head.next = removeElements(head.next, val);
        return head.val == val ? head.next : head;
    }
```



## 递归的微观

![picture19](../photo/19.jpg)
![picture18](../photo/18.jpg)
![picture21](../photo/21.jpg)


## 更多和链表相关的问题

>   链表与递归紧密相关

### 链表的多种形态

![picture17](../photo/17.jpg)

![picture19](../photo/19.jpg)



# @树结构

## 二叉树

-   动态数据结构
-   唯一根节点，每个节点最多两个孩子，末端为叶子节点（无孩子）
-   每个节点最多一个父亲
-   具有天然的递归结构
-   不一定为满二叉（每个节点都有两个孩子）

### 满二叉树

>   除了叶子节点外，每个节点都有左右两个子树

### 完全二叉树

>   将数据按照二叉树的形状一层一层从左到右加入树中

![61](../photo/61.jpg)





## 二分搜索树

>   Binary Search  Tree
>
>   高效  存储数据高效
>
>   每个节点的值，比左边大，比右边小
>
>   存储的元素必须有可比较性
>
>   不包含重复元素

**Blinary_Search_tree包**

### 顺序性

后继      前序

successor, predecessor


![picture27](../photo/27.jpg)

![picture27](../photo/26.jpg)

-   floor   比确定值小的元素中最大的那个
-   ceil      比确定值大的元素最小的那个
-   rank      确定值的排名
-   select    确定排名的值
-   维护size     每个节点以自身为根节点的树有几个节点（包括自身）

![picture27](../photo/24.jpg)
![picture27](../photo/25.jpg)
![picture27](../photo/22.jpg)



## Set  Map

## Set

-   通过二叉树实现集合
-   Set包
-   通过链表实现集合
-   Set_Linkedlist包

### 有序集合和无序集合

-   有序集合基于搜索树的实现
-   无序集合基于哈希表的实现

### 多重集合

-   可以重复元素

### 时间复杂度




![image-20200407100212318](..\photo\30.jpg)

![image-20200407100212318](..\photo\32.jpg)

![image-20200407100212318](..\photo\40.jpg)

![image-20200407100212318](..\photo\31.jpg)

![image-20200407100212318](..\photo\34.jpg)

![image-20200407100212318](..\photo\35.jpg)


## Map映射

>   可称字典，  单词--> 解释

-   存储（键，值）  数据对的数据结构（Key，Value）
-   根据键，拿到值
-   非常容易使用链表或者二分搜素树实现

Map项目

-   基于链表的映射
-   基于二叉树的映射
-   二叉树明显优于链表

### 有序映射和无序映射

-   有序映射基于搜索树的实现
-   无序映射基于哈希表的实现

### 多重映射

键可以重复



## @树的不同形式



## 优先队列

-   普通队列： 先进先出，后进后出
-   优先队列： 出队顺序与入队顺序无关，与优先级有关
-   动态 ，  优先级不断变化, 按照一定规则来出队

![image-20200407100212318](..\photo\40.jpg)

### 通过堆来实现优先队列

#### 二叉堆

-   除了根节点，所有节点均小于等于父节点，又称最大堆（反之为最小堆）
-   一种完全二叉树，将元素一层层从左到右添加到树结构中

![image-20200407095922492](..\photo\37.jpg)

-   通过数组来表示二叉堆
-   索引从零开始

![image-20200407100003511](..\photo\38.jpg)

-   索引从一开始

![image-20200407100128963](..\photo\39.jpg)

##### sifi up

元素上浮操作，在插入元素时，先将新元素放于树的末端（数组的末尾），然后利用递归将其上调到合适的位置

##### sift  down

元素下沉操作，在删除最大元素时，先将根节点与末端交换，去掉交换后的末端，通过递归将此时的根节点的元素下沉

##### replace

取出堆中的最大元素，并且替换成元素e

##### heapify

-   将任意的数组整理成堆的形状
-   复杂度为O(n)

#### d 叉堆 d-ary heap

![36](..\photo\36.jpg)

#### 索引堆

#### 斐波那契堆



## 线段树（区间树）

**Segment  Tree**

![36](..\photo\52.jpg)
![36](..\photo\51.jpg)
![36](..\photo\49.jpg)
![36](..\photo\48.jpg)
![36](..\photo\47.jpg)
![36](..\photo\45.jpg)
![36](..\photo\44.jpg)
![36](..\photo\36.jpg)
![36](..\photo\43.jpg)

### 懒惰更新


![36](..\photo\42.jpg)

![36](..\photo\41.jpg)


### 树状数组

**Binary Index Tree**

### RMQ   

range minimum query



## Trie  字典树

图

Trie在进行查找操作时，与数据量无关，只与要查找的数据有关

### 前缀搜索

### Trie的 删除操作

### 局限性

```java
空间
class Node{
    boolean isWord;
    TreeMap<char, Node> next;
}    //对于存储26个字母来说，比字符串存储空间大了26倍
```

解决方法：

![53](../photo/53.jpg)

![54](../photo/54.jpg)

### 更多字符串问题

-   子串查询
-   文件压缩
-   模式匹配
-   编译原理
-   DNA RNA 



## 并查集

>   **Union Find**
>
>   连接问题，路径问题
>
>   网络中节点间的连接状态

对于一组数据，主要支持两个动作：

```
合并集合
union(p, q)
查询是否为同一集合
isConnected(p, q)
```

```
每个数据都有个ID值，相同ID值的数据在同一集合
将元素合并只需要将其的ID值改为
```

**通过树结构实现并查集，孩子指向父类的树**

![video](../photo/345.gif)



### 优化

-   合并操作时，两个树的合并关系随机，为了保持高度最小，应在合并前判断，以节点数最小的数来依附节点数较大的数
-   实际上，在合并前判断，以高度来判断依托关系更佳

![55](../photo/55.jpg)



以节点数判断

![55](../photo/56.jpg)



以高度来判断

![55](../photo/57.jpg)



### 路径压缩

>   Path Compression

![58](../photo/59.jpg)



![58](../photo/60.jpg)



### 时间复杂度

**在进行路径压缩下**

![58](../photo/58.jpg)



## 平衡二叉树与AVL树

### 平衡二叉树

>   **对于任意一个节点，左子树和右子树的高度差不能超过1**

![66](../photo/66.jpg)

![66](../photo/64.jpg)

### 自平衡

>   在进行添加与删除操作时，会出现打破平衡

#### 右旋转 与 左旋转

**当发生左子树高度大于右子树高度，在左子树的左孩子位置添加元素时，进行右旋转，反之，进行左旋转**



![66](../photo/62.jpg)



```
进行右旋转操作
```

![66](../photo/69.gif)

```
左旋转同理
```



```
当出现根节点的右子树的左子树出现不平衡时
先对左子树进行右旋转操作，将其变成 RR 型
反之同理
```

![66](../photo/67.gif)

![66](../photo/68.gif)



## 红黑树

>   是一种二分搜索树

### 红黑树与2 - 3 树的等价性

### 2--3树

>   **满足二分搜索树的性质**
>
>   **绝对平衡的树，任意节点的左右子树高度一定相同**
>
>   **节点可以存放一个元素或者两个元素**
>
>   **每个节点有 两个 或者 三个 孩子  称为2--3 树**
>
>   **有两个孩子的节点称为  2节点**
>
>   **有三个孩子的节点称为  3节点**

### 2--3树维持绝对平衡

#### 在添加操作中

-   永远添加到最后找到的叶子节点中，不会添加到空的位置上

-   当只有一个二节点时，添加一个元素，这个元素与根节点（也是最后的节点）融合，为一个三节点
-   当只有一个三节点时，添加元素，这个元素与根节点融合，成为一个四节点，随后，分成一颗高度为2，有一个根节点，两个左右孩子的2--3树（也是二分搜索树）

![71](../photo/78.jpg)

![70](../photo/77.jpg)

![70](../photo/77.jpg)

![70](../photo/75.jpg)



### 红黑树和2--3树

![70](../photo/74.jpg)

![70](../photo/73.jpg)

![70](../photo/72.jpg)



### 红黑树性质

>   **所有节点非红即黑**
>
>   **根节点为黑色**
>
>   **最后NULL节点为黑**
>
>   **红节点的孩子一定为黑**
>
>   **黑平衡**

-   保持“黑平衡”

-   不是平衡二叉树

-   最大高度为 h = 2log(n)     高度复杂度为 O(n)

-   增删改查复杂度为 O(logn)

### 添加元素

-   2--3树中添加一个新元素
-   或者添加进2-节点， 形成一个3- 节点
-   或者添加进 3- 节点， 暂时形成一个 4- 节点  然后不断向上融合 直到根节点为止
-   永远添加红色节点
-   保持根节点为黑色节点



1.  在添加节点时，若只有一个根节点，要添加的节点比根节点大，按照二分搜索树规律，应在根节点的右孩子位置，但此时不平衡，进行左旋转操作（与AVLTree的自平衡类似）
2.  向红黑树中的 3-- 节点添加元素，颜色翻转
![80](../photo/80.jpg)
![80](../photo/79.jpg)
3.  向一黑一红的树，添加元素，若为红节点的左节点，需要进行右旋转，使之平衡
![66](../photo/69.gif)



### 性能分析

![80](../photo/82.jpg)

![80](../photo/81.jpg)



## 哈希表

>   每个字符都和索引相对应
>
>   字符与索引之间存在某种函数关系, 称为哈希函数
>
>   查找操作为 O(1)

### 用空间换时间

-   哈希表是时间与空间的平衡
-   哈希函数设计很重要
-   “键” 通过哈希函数得到的 “索引” 分布越均匀越好

![85](../photo/86.jpg)

### 哈希函数设计

>   哈希函数的一般设计原则

#### 整型

![83](../photo/83.jpg)
![83](../photo/84.jpg)

-   取后六位的mod 时， 存在陷阱，前两位是出生的日期，只可能咋1--31之间，出现了分布不均匀的情况， 也没有利用所有信息，增加了哈希冲突的几率
-   大整数解决方法： 模 一个 素数

![83](../photo/90.jpg)

图

#### 浮点型

![83](../photo/92.jpg)

#### 字符串

![83](../photo/93.jpg)

![83](../photo/94.jpg)

![83](../photo/95.jpg)

#### 复合类型

![83](../photo/96.jpg)

#### 函数设计原则

1.  一致性： 如果 a == b, 则 hash(a) == hash(b)
2.  高效性： 计算高效简便
3.  均匀性： 哈希值均匀分布



### 哈希冲突的处理   

### 链地址法

![83](../photo/100.jpg)

![83](../photo/101.jpg)

![83](../photo/102.jpg)

### 开放地址法

- 每个地址对于所有元素都开放
- 线性探测：产生哈希冲突时，元素添加到下一个未被占用的地址上
- 平方探测：产生哈希冲突时，元素添加到 +1，+4，+9，+16的平方地址上去

### 再哈希法

Rehashing



## 更多的数据结构

![83](../photo/99.jpg)

![83](../photo/98.jpg)

![83](../photo/97.jpg)